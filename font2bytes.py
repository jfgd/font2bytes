#!/usr/bin/env python3
#==========================================================================
# Copyright (c) theHEXstyle, 2023-2024
# Copyright (c) jfgd, 2026
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see
# <https://www.gnu.org/licenses/>.
#==========================================================================

import argparse
from pathlib import Path
from PIL import ImageDraw, ImageFont, Image
from numpy import asarray, ceil, array, sum, concatenate


def createTMPimage(
    font: ImageFont.FreeTypeFont, height: int, width: int, ASCII: int
) -> Image.Image:
    image = Image.new("RGB", (width, height), color=(0, 0, 0))
    draw = ImageDraw.Draw(image)
    if font.getlength(chr(ASCII)) > width:
        temp_image = Image.new(
            "RGB", (int(font.getlength(chr(ASCII))), height), color=(0, 0, 0)
        )
        temp_draw = ImageDraw.Draw(temp_image)
        temp_draw.text((0, 0), chr(ASCII), font=font)
        squeezed_image = temp_image.resize((width, height), Image.Resampling.HAMMING)
        image.paste(squeezed_image, (0, 0))
    else:
        draw.text((0, 0), chr(ASCII), font=font)
    return image


def readImage2Binary(image: Image.Image, ASCII: int):
    data = asarray(image)
    binary_map = data[:, :, 0]
    return binary_map


def convertMap2Hex(height: int, width: int, threshold: int, binary_map) -> list:
    hex_map = []
    binary_byte = array([128, 64, 32, 16, 8, 4, 2, 1])
    for line in range(binary_map.shape[0]):
        for bit_chunks in range(int(ceil(width / 8))):
            tmp = binary_map[line][bit_chunks * 8 : (min((bit_chunks + 1) * 8, width))]
            tmp = array(list(map(lambda x: int(x > threshold), tmp)))
            tmp = concatenate((tmp, array([0] * (8 - len(tmp)))))  # padding with zeros
            binary_value = int(sum(tmp * binary_byte))
            hex_map.append(f"{binary_value:#0{4}x}")

    return hex_map


def write_file_intro(f) -> None:
    f.write("/* File automatically generated by font2bytes */\n\n")
    f.write('#include "fonts.h"\n\n')
    f.write("static const uint8_t Font_Table [] = \n")
    f.write("{\n")


def write_file_closure(f, font_name: str, height: int, width: int):
    f.write("};\n\n")
    f.write(f"sFONT {font_name} = {{\n")
    f.write("\tFont_Table,\n")
    f.write(f"\t{width}, /* Width */\n")
    f.write(f"\t{height}, /* Height */\n")
    f.write("};\n\n")


def write_letter(f, height, width, hex_map):
    f.write(f'\t// ASCII: {ASCII} "{chr(ASCII)}" ({width} pixels wide)\n')

    count = 0
    f.write("\t")

    for item in hex_map:
        f.write(f"{item}, ")
        count += 1
        if count == 3:
            count = 0
            f.write("\n\t")

    f.write("\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="font2bytes",
        description="Generate C/C++ font files for e-Paper "
        "(WaveShare like) from .ttf files",
    )

    parser.add_argument(
        "-t",
        "--ttf-input-file",
        type=Path,
        default="./fonts/Roboto-Regular.ttf",
        help="A .ttf font file",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "-o",
        "--output-file",
        type=Path,
        help="C/C++ output filename",
    )
    group.add_argument(
        "-d",
        "--output-dir",
        type=Path,
        default="./output/",
        help="C/C++ output directory. Use --font-name as file name or guess it.",
    )
    parser.add_argument(
        "-n",
        "--font-name",
        type=str,
        help="Name of the sFONT object in the C file. "
        "If unspecified derive it form input file name.",
    )
    parser.add_argument(
        "--height", type=int, default=36, help="Height of the generated font in pixel"
    )
    parser.add_argument(
        "--width", type=int, default=22, help="Height of the generated font in pixel"
    )
    parser.add_argument(
        "--threshold",
        type=int,
        default=120,
        help="Image intensity threshold for binary conversion. "
        "It changes the contrast of the final font.",
    )
    parser.add_argument(
        "--font-offset",
        type=int,
        default=4,
        help="Font offset, recommended to be at least 4.",
    )
    parser.add_argument(
        "-b",
        "--bmp-dir",
        type=Path,
        help="Folder to save BMP intermediate image, if unspecified "
        "BMP image are not saved. Useful for debugging.",
    )

    args = parser.parse_args()

    if not args.ttf_input_file.is_file():
        print(f"File '{args.ttf_input_file}' can not be read")
        exit(1)

    if args.bmp_dir is not None:
        if not args.bmp_dir.is_dir():
            print(f"Directory '{args.bmp_dir}' does not exist")
            exit(1)

    if args.output_dir is not None:
        if not args.output_dir.is_dir():
            print(f"Directory '{args.output_dir}' does not exist")
            exit(1)

    if args.font_name is None:
        font_name = "Font" + args.ttf_input_file.stem
        for i in [" ", "-"]:
            font_name = font_name.replace(i, "")
        font_name += f"{args.height}"
    else:
        font_name = args.font_name

    if args.output_file is not None:
        output_file = args.output_file
    else:
        output_file = args.output_dir / f"{font_name}.c"

    print(
        f"Generating font '{font_name}' in {output_file} from TTF file {args.ttf_input_file}"
    )

    with open(output_file, "w") as cfile:
        font = ImageFont.truetype(args.ttf_input_file, args.height - args.font_offset)

        write_file_intro(cfile)

        print("Generating:", end="")
        for ASCII in range(32, 127):
            print(chr(ASCII), end="")

            image = createTMPimage(font, args.height, args.width, ASCII)
            if args.bmp_dir is not None:
                image.save(args.bmp_dir / f"{ASCII}.bmp")
            binary_map = readImage2Binary(image, ASCII)
            hex_map = convertMap2Hex(
                args.height, args.width, args.threshold, binary_map
            )
            write_letter(cfile, args.height, args.width, hex_map)

        write_file_closure(cfile, font_name, args.height, args.width)
        print()
